#include "ros/ros.h"
#include "armada_flexbe_utilities/GraspWaypoints.h"
#include "armada_flexbe_utilities/GraspPoses.h"
#include "armada_flexbe_utilities/GraspPosesList.h"
#include <gpd_ros/GraspConfigList.h>
#include <gpd_ros/GraspConfig.h>
#include <tf/transform_listener.h>

using namespace std;

class GraspWaypointService
{
protected:

  ros::NodeHandle nh_;
  ros::ServiceServer graspWaypointService;
  double gripper_offset;
  double approach_dist;
  double retreat_dist;
  double grasp_rot_x;
  double grasp_rot_y;
  double grasp_rot_z;
  double grasp_rot_w;

  string global_frame;
  string robot_frame;

public:

  /**
   * Class Constructor.
   *
   * Constructor for GraspWaypointService class.
   *
   * @param[in] nh A ROS NodeHandle object.
   */
  GraspWaypointService(ros::NodeHandle nh) :
    nh_(nh)
  {
    graspWaypointService = nh.advertiseService("calculate_grasp_waypoints", &GraspWaypointService::calculateGraspWaypoints, this);
  }

  /**
   * Generate a set of grasp waypoints (pre, target and post poses).
   *
   * Given a list of grasp target candidates, generate a set of waypoint poses (pre-approach, target pose, post-retreat) for each candidate.
   *
   * @param[in] req geometry_msgs/Point Position of grasp target.
   * @param[out] res armada_flexbe_utilities/GraspPosesList Container of sets of pose waypoints for grasp target.
   * @return Bool Service completion result.
   */
  bool calculateGraspWaypoints(armada_flexbe_utilities::GraspWaypoints::Request &req,
                               armada_flexbe_utilities::GraspWaypoints::Response &res)
  {
    // These should be defined in a parameter file as static for a robot/gripper configuration but modifiable per robot
    nh_.getParam("/end_effector/gripper_offset", gripper_offset);
    nh_.getParam("/end_effector/approach_dist", approach_dist);
    nh_.getParam("/end_effector/retreat_dist", retreat_dist);
    // These parameters describe the rotation of the gripper about the wrist (different from the urdf expectations) for proper transformations
    // seems to be a common enough occurance but need to look into more deeply for more permanent solution
    nh_.getParam("/end_effector/grasping/grasp_rot_x", grasp_rot_x);
    nh_.getParam("/end_effector/grasping/grasp_rot_y", grasp_rot_y);
    nh_.getParam("/end_effector/grasping/grasp_rot_z", grasp_rot_z);
    nh_.getParam("/reference_frame/global_frame", global_frame);
    nh_.getParam("/reference_frame/robot_frame", robot_frame);

    unsigned long candidates_list_size = req.pose_list.size();
    for (unsigned long i=0; i < candidates_list_size; i++) {
      res.grasp_poses_list.poses.push_back(calculateGraspPoses(req.pose_list[i]));
    }

    return true;
  }

  /**
   * Generate grasp picking poses from a grasp candidate.
   *
   * Given a grasp candidate, generate a set of poses (pre-grasp, target pose, post-grasp).
   * This code uses a modification of the method for using GPD implemented in:
   * https://gist.github.com/tkelestemur/60401be131344dae98671b95d46060f8
   *
   * @param[in] pose geometry_msgs/Pose A pose generated by a grasping algorithm.
   * @return armada_flexbe_utilities::GraspPoses A set of poses for picking.
   */
  armada_flexbe_utilities::GraspPoses calculateGraspPoses(geometry_msgs::Pose pose)
  {
    armada_flexbe_utilities::GraspPoses grasp_poses;

    tf::Vector3 tr_grasp_base(pose.position.x, pose.position.y - 0.04, pose.position.z);
    tf::Quaternion rot_grasp_base(pose.orientation.x, pose.orientation.y, pose.orientation.z, pose.orientation.w);
    tf::Transform tf_grasp_base(rot_grasp_base, tr_grasp_base);
    tf::StampedTransform tf_base_odom;

    try {
      tf::TransformListener listener;
      listener.waitForTransform(global_frame, robot_frame, ros::Time::now(), ros::Duration(3.0) );
      listener.lookupTransform(global_frame, robot_frame, ros::Time::now(), tf_base_odom);
    } catch (tf::TransformException err) {
      ROS_ERROR("%s", err.what());
    }

    tf::Quaternion gripper_rot_base;
    gripper_rot_base.setRPY(grasp_rot_x, grasp_rot_y, grasp_rot_z);
    tf::Transform tf_grasp_odom_(gripper_rot_base, tf::Vector3(0, 0, -gripper_offset));
    tf::Transform tf_grasp_odom = tf_base_odom * tf_grasp_base * tf_grasp_odom_;
    tf::poseTFToMsg(tf_grasp_odom, grasp_poses.target);

    tf::Transform tf_pregrasp_odom_(tf::Quaternion(0, 0, 0, 1), tf::Vector3(0, 0, -approach_dist));
    tf::Transform tf_pregrasp_odom = tf_grasp_odom * tf_pregrasp_odom_;
    tf::poseTFToMsg(tf_pregrasp_odom, grasp_poses.pre);

    tf::Transform tf_aftergrasp_odom_(tf::Quaternion(0, 0, 0, 1), tf::Vector3(0, 0, -retreat_dist));
    tf::Transform tf_aftergrasp_odom = tf_grasp_odom * tf_aftergrasp_odom_;
    tf::poseTFToMsg(tf_aftergrasp_odom, grasp_poses.post);

    return grasp_poses;
  }
};

int main(int argc, char **argv)
{
  ros::init(argc, argv, "grasp_waypoints_service");
  ros::NodeHandle nh;

  GraspWaypointService graspWaypointService = GraspWaypointService(nh);
  ros::spin();

  return 0;
}
